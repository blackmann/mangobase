import { Definition, DefinitionType } from './schema'

type SortOrder = -1 | 1

interface Cursor<T = any> {
  exec(): Promise<T>
  limit(n: number): Cursor<T>
  populate(
    fields: (string | { collection: string; field: string })[]
  ): Cursor<T>
  select(fields: string[]): Cursor<T>
  skip(n: number): Cursor<T>
  sort(config: Record<string, SortOrder>): Cursor<T>
}

interface Filter {
  limit?: number
  populate?: string[]
  select?: string[]
  skip?: number
  sort?: Record<string, SortOrder>
}

type Data = Record<string, any>

interface Index {
  // when sort is not specified, it defaults to ascending (1)
  fields: [string, SortOrder][] | string[]
  options: {
    unique?: boolean
    sparse?: boolean
  }
}

interface RenameField {
  type: 'rename-field'
  collection: string
  from: string
  to: string
}

interface RemoveField {
  type: 'remove-field'
  collection: string
  field: string
}

interface AddField {
  type: 'add-field'
  name: string
  definition: Definition
}

interface RenameCollection {
  type: 'rename-collection'
  collection: string
  to: string
}

// When adding support for RDBMS, we need to add `CreateCollection`, `DropCollection`, etc.
type MigrationStep = RenameField | RemoveField | AddField | RenameCollection

interface Migration {
  /**
   * This is an autogenerated randomstring of the migration. This is useful especially in
   * version control. When there's a conflict on this ID in the manifest file, it signals
   * a clash in the migration, so `version` number should be bumped
   */
  id: string
  version: number
  steps: MigrationStep[]
}

interface Database {
  /**
   * Casting is an affordance to convert data in to formats that database prefers.
   * This is normally called during schema validation.
   */
  cast(value: any, type: DefinitionType): any
  count(collection: string, query: Record<string, any>): Promise<number>
  find<T = any>(collection: string, query: Record<string, any>): Cursor<T[]>
  /**
   * @param data data or array of data to be inserted
   */
  create<T = any>(collection: string, data: Data | Data[]): Cursor<T | T[]>
  patch<T = any>(
    collection: string,
    id: string | string[],
    data: Record<string, any>
  ): Cursor<T | T[]>
  remove(collection: string, id: string | string[]): Promise<void>
  migrate(migration: Migration): Promise<void>
  /**
   * This method removes and adds the indexes as necessary
   */
  syncIndex(collection: string, indexes: Index[]): Promise<void>

  // [ ] Properly standardize this API
  aggregate(
    collection: string,
    query: Record<string, any>,
    filter: Filter,
    operations: Record<string, any>[]
  ): Promise<any>
}

export type {
  Cursor,
  Database,
  Filter as DatabaseFilter,
  Index,
  Migration,
  MigrationStep,
  SortOrder,
}
